package com.github.zharovvv.android.core.sandbox.data.binding

import android.os.Bundle
import com.github.zharovvv.android.core.sandbox.databinding.ActivityDataBindingExampleBinding
import com.github.zharovvv.core.ui.activity.LogLifecycleAppCompatActivity

class DataBindingExampleActivity : LogLifecycleAppCompatActivity() {

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)

        bindData()
    }

    /**
     * Если мы теперь в коде будем изменять объект Employee, то данные на экране меняться не будут.
     * Они считались один раз и далее не отслеживаются (при такой реализации).
     * Чтобы экран получил новые данные, надо снова передать биндингу измененный объект Employee:
     * ```
     * binding.setEmployee(employee)
     * ```
     * Или можно вызвать:
     * ```
     * binding.invalidateAll()
     * ```
     * Биндинг в этом случае считает новые данные с ранее полученного объекта Employee.
     *
     *
     * If view binding is enabled for a module, a binding class is generated for each
     * XML layout file that the module contains. Each binding class contains references to
     * the root view and all views that have an ID.
     * The name of the binding class is generated by converting the name of the XML file
     * to Pascal case and adding the word "Binding" to the end.
     *
     * __Note__: Fragments outlive their views.
     * Make sure you clean up any references to the binding class instance in the fragment's
     * onDestroyView() method.
     *
     * При текущей реализации "дешевле" использовать __View Binding__, который:
     * * не требует специально помеченных XML-файлов.
     * * Привязка Представлений не требует обработки аннотаций, поэтому время компиляции сокращается.
     *
     * При всем этом View Binding имеет следующие ограничения:
     * * Привязка представления не поддерживает переменные макета или выражения макета,
     * поэтому его нельзя использовать для объявления динамического содержимого
     * пользовательского интерфейса прямо из файлов макета XML.
     * * Привязка представления не поддерживает двустороннюю привязку данных.
     */
    private fun bindData() {
        val employee = Employee(1, "John Smith", "London", 10000)
//        val binding: ActivityDataBindingExampleBinding =    //сгенерированный класс.
        // Имя этого класса берется из имени layout файла + Binding
        //ActivityDataBindingExampleBinding все знает о нашем layout:
        // какие View там есть, какие переменные (variable) мы там указывали,
        // и как все это связать друг с другом, чтобы данные из переменных попадали в View.
//            DataBindingUtil.setContentView(this, R.layout.activity_data_binding_example)
        //Другой способ:
        val binding = ActivityDataBindingExampleBinding.inflate(layoutInflater)
        val view = binding.root
        setContentView(view)
        binding.employee = employee //Метод setEmployee был сгенерирован в классе биндинга,
        // т.к. мы описали переменную employee в layout файле.

        with(binding) {
            textViewEmployeeAddress //Получение view из binding-а
            textViewEmployeeName    //Только для view с ID
        }
    }
}